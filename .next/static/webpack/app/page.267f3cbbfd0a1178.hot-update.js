"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./chessLogic.ts":
/*!***********************!*\
  !*** ./chessLogic.ts ***!
  \***********************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getValidMoves: function() { return /* binding */ getValidMoves; },\n/* harmony export */   isCheck: function() { return /* binding */ isCheck; },\n/* harmony export */   isCheckmate: function() { return /* binding */ isCheckmate; }\n/* harmony export */ });\nfunction getValidMoves(board, row, col) {\n    let considerPin = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;\n    const piece = board[row][col];\n    const isWhite = piece === piece.toUpperCase();\n    let moves = [];\n    switch(piece.toLowerCase()){\n        case \"p\":\n            moves = getPawnMoves(board, row, col, isWhite);\n            break;\n        case \"r\":\n            moves = getRookMoves(board, row, col, isWhite);\n            break;\n        case \"n\":\n            moves = getKnightMoves(board, row, col, isWhite);\n            break;\n        case \"b\":\n            moves = getBishopMoves(board, row, col, isWhite);\n            break;\n        case \"q\":\n            moves = getQueenMoves(board, row, col, isWhite);\n            break;\n        case \"k\":\n            moves = getKingMoves(board, row, col, isWhite);\n            break;\n    }\n    if (considerPin) {\n        moves = moves.filter((param)=>{\n            let [newRow, newCol] = param;\n            return !movePutsOwnKingInCheck(board, row, col, newRow, newCol);\n        });\n    }\n    return moves;\n}\nfunction getPawnMoves(board, row, col, isWhite) {\n    var _board_;\n    const moves = [];\n    const direction = isWhite ? -1 : 1;\n    const startRow = isWhite ? 6 : 1;\n    if (((_board_ = board[row + direction]) === null || _board_ === void 0 ? void 0 : _board_[col]) === \"\") {\n        var _board_1;\n        moves.push([\n            row + direction,\n            col\n        ]);\n        if (row === startRow && ((_board_1 = board[row + 2 * direction]) === null || _board_1 === void 0 ? void 0 : _board_1[col]) === \"\") {\n            moves.push([\n                row + 2 * direction,\n                col\n            ]);\n        }\n    }\n    for (const dcol of [\n        -1,\n        1\n    ]){\n        var _board_2;\n        if (((_board_2 = board[row + direction]) === null || _board_2 === void 0 ? void 0 : _board_2[col + dcol]) && isOpponentPiece(board[row + direction][col + dcol], isWhite)) {\n            moves.push([\n                row + direction,\n                col + dcol\n            ]);\n        }\n    }\n    return moves;\n}\nfunction getRookMoves(board, row, col, isWhite) {\n    return getStraightMoves(board, row, col, isWhite);\n}\nfunction getKnightMoves(board, row, col, isWhite) {\n    const moves = [];\n    const knightMoves = [\n        [\n            -2,\n            -1\n        ],\n        [\n            -2,\n            1\n        ],\n        [\n            -1,\n            -2\n        ],\n        [\n            -1,\n            2\n        ],\n        [\n            1,\n            -2\n        ],\n        [\n            1,\n            2\n        ],\n        [\n            2,\n            -1\n        ],\n        [\n            2,\n            1\n        ]\n    ];\n    for (const [dr, dc] of knightMoves){\n        const newRow = row + dr;\n        const newCol = col + dc;\n        if (isValidPosition(newRow, newCol) && (board[newRow][newCol] === \"\" || isOpponentPiece(board[newRow][newCol], isWhite))) {\n            moves.push([\n                newRow,\n                newCol\n            ]);\n        }\n    }\n    return moves;\n}\nfunction getBishopMoves(board, row, col, isWhite) {\n    return getDiagonalMoves(board, row, col, isWhite);\n}\nfunction getQueenMoves(board, row, col, isWhite) {\n    return [\n        ...getStraightMoves(board, row, col, isWhite),\n        ...getDiagonalMoves(board, row, col, isWhite)\n    ];\n}\nfunction getKingMoves(board, row, col, isWhite) {\n    const moves = [];\n    const kingMoves = [\n        [\n            -1,\n            -1\n        ],\n        [\n            -1,\n            0\n        ],\n        [\n            -1,\n            1\n        ],\n        [\n            0,\n            -1\n        ],\n        [\n            0,\n            1\n        ],\n        [\n            1,\n            -1\n        ],\n        [\n            1,\n            0\n        ],\n        [\n            1,\n            1\n        ]\n    ];\n    for (const [dr, dc] of kingMoves){\n        const newRow = row + dr;\n        const newCol = col + dc;\n        if (isValidPosition(newRow, newCol) && (board[newRow][newCol] === \"\" || isOpponentPiece(board[newRow][newCol], isWhite))) {\n            moves.push([\n                newRow,\n                newCol\n            ]);\n        }\n    }\n    return moves;\n}\nfunction getStraightMoves(board, row, col, isWhite) {\n    const moves = [];\n    const directions = [\n        [\n            -1,\n            0\n        ],\n        [\n            1,\n            0\n        ],\n        [\n            0,\n            -1\n        ],\n        [\n            0,\n            1\n        ]\n    ];\n    for (const [dr, dc] of directions){\n        let newRow = row + dr;\n        let newCol = col + dc;\n        while(isValidPosition(newRow, newCol)){\n            if (board[newRow][newCol] === \"\") {\n                moves.push([\n                    newRow,\n                    newCol\n                ]);\n            } else if (isOpponentPiece(board[newRow][newCol], isWhite)) {\n                moves.push([\n                    newRow,\n                    newCol\n                ]);\n                break;\n            } else {\n                break;\n            }\n            newRow += dr;\n            newCol += dc;\n        }\n    }\n    return moves;\n}\nfunction getDiagonalMoves(board, row, col, isWhite) {\n    const moves = [];\n    const directions = [\n        [\n            -1,\n            -1\n        ],\n        [\n            -1,\n            1\n        ],\n        [\n            1,\n            -1\n        ],\n        [\n            1,\n            1\n        ]\n    ];\n    for (const [dr, dc] of directions){\n        let newRow = row + dr;\n        let newCol = col + dc;\n        while(isValidPosition(newRow, newCol)){\n            if (board[newRow][newCol] === \"\") {\n                moves.push([\n                    newRow,\n                    newCol\n                ]);\n            } else if (isOpponentPiece(board[newRow][newCol], isWhite)) {\n                moves.push([\n                    newRow,\n                    newCol\n                ]);\n                break;\n            } else {\n                break;\n            }\n            newRow += dr;\n            newCol += dc;\n        }\n    }\n    return moves;\n}\nfunction isValidPosition(row, col) {\n    return row >= 0 && row < 8 && col >= 0 && col < 8;\n}\nfunction isOpponentPiece(piece, isWhite) {\n    return piece !== \"\" && (isWhite ? piece === piece.toLowerCase() : piece === piece.toUpperCase());\n}\nfunction isCheck(board, isWhiteKing) {\n    const kingPiece = isWhiteKing ? \"K\" : \"k\";\n    let kingRow = -1, kingCol = -1;\n    for(let row = 0; row < 8; row++){\n        for(let col = 0; col < 8; col++){\n            if (board[row][col] === kingPiece) {\n                kingRow = row;\n                kingCol = col;\n                break;\n            }\n        }\n        if (kingRow !== -1) break;\n    }\n    for(let row = 0; row < 8; row++){\n        for(let col = 0; col < 8; col++){\n            if (board[row][col] !== \"\" && isOpponentPiece(board[row][col], isWhiteKing)) {\n                const moves = getValidMoves(board, row, col, false);\n                if (moves.some((param)=>{\n                    let [r, c] = param;\n                    return r === kingRow && c === kingCol;\n                })) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\nfunction isCheckmate(board, isWhiteKing) {\n    if (!isCheck(board, isWhiteKing)) return false;\n    for(let row = 0; row < 8; row++){\n        for(let col = 0; col < 8; col++){\n            const piece = board[row][col];\n            if (piece !== \"\" && (isWhiteKing ? piece === piece.toUpperCase() : piece === piece.toLowerCase())) {\n                const moves = getValidMoves(board, row, col);\n                if (moves.length > 0) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}\nfunction movePutsOwnKingInCheck(board, fromRow, fromCol, toRow, toCol) {\n    const newBoard = board.map((row)=>[\n            ...row\n        ]);\n    newBoard[toRow][toCol] = newBoard[fromRow][fromCol];\n    newBoard[fromRow][fromCol] = \"\";\n    return isCheck(newBoard, newBoard[toRow][toCol] === newBoard[toRow][toCol].toUpperCase());\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFVQSxNQUFNSSxXQUFXLEVBQUMsR0FBSTtnQkFDL0YsTUFBTUQsUUFBUVIsY0FBY0MsT0FBT0MsS0FBS0M7Z0JBQ3hDLElBQUlLLE1BQU1rQyxNQUFNLEdBQUcsR0FBRztvQkFDbEIsT0FBTztnQkFDWDtZQUNKO1FBQ0o7SUFDSjtJQUVBLE9BQU87QUFDWDtBQUVBLFNBQVN2Qix1QkFBdUJsQixLQUFZLEVBQUUwQyxPQUFlLEVBQUVDLE9BQWUsRUFBRUMsS0FBYSxFQUFFQyxLQUFhO0lBQ3hHLE1BQU1DLFdBQVc5QyxNQUFNK0MsR0FBRyxDQUFDOUMsQ0FBQUEsTUFBTztlQUFJQTtTQUFJO0lBQzFDNkMsUUFBUSxDQUFDRixNQUFNLENBQUNDLE1BQU0sR0FBR0MsUUFBUSxDQUFDSixRQUFRLENBQUNDLFFBQVE7SUFDbkRHLFFBQVEsQ0FBQ0osUUFBUSxDQUFDQyxRQUFRLEdBQUc7SUFDN0IsT0FBT1gsUUFBUWMsVUFBVUEsUUFBUSxDQUFDRixNQUFNLENBQUNDLE1BQU0sS0FBS0MsUUFBUSxDQUFDRixNQUFNLENBQUNDLE1BQU0sQ0FBQ3ZDLFdBQVc7QUFDMUYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vY2hlc3NMb2dpYy50cz8yMDY3Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB0eXBlIFBpZWNlID0gJ3AnIHwgJ3InIHwgJ24nIHwgJ2InIHwgJ3EnIHwgJ2snIHwgJ1AnIHwgJ1InIHwgJ04nIHwgJ0InIHwgJ1EnIHwgJ0snIHwgJyc7XG5leHBvcnQgdHlwZSBCb2FyZCA9IFBpZWNlW11bXTtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldFZhbGlkTW92ZXMoYm9hcmQ6IEJvYXJkLCByb3c6IG51bWJlciwgY29sOiBudW1iZXIsIGNvbnNpZGVyUGluOiBib29sZWFuID0gdHJ1ZSk6IFtudW1iZXIsIG51bWJlcl1bXSB7XG4gICAgY29uc3QgcGllY2UgPSBib2FyZFtyb3ddW2NvbF07XG4gICAgY29uc3QgaXNXaGl0ZSA9IHBpZWNlID09PSBwaWVjZS50b1VwcGVyQ2FzZSgpO1xuICAgIGxldCBtb3ZlczogW251bWJlciwgbnVtYmVyXVtdID0gW107XG5cbiAgICBzd2l0Y2ggKHBpZWNlLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgY2FzZSAncCc6IG1vdmVzID0gZ2V0UGF3bk1vdmVzKGJvYXJkLCByb3csIGNvbCwgaXNXaGl0ZSk7IGJyZWFrO1xuICAgICAgICBjYXNlICdyJzogbW92ZXMgPSBnZXRSb29rTW92ZXMoYm9hcmQsIHJvdywgY29sLCBpc1doaXRlKTsgYnJlYWs7XG4gICAgICAgIGNhc2UgJ24nOiBtb3ZlcyA9IGdldEtuaWdodE1vdmVzKGJvYXJkLCByb3csIGNvbCwgaXNXaGl0ZSk7IGJyZWFrO1xuICAgICAgICBjYXNlICdiJzogbW92ZXMgPSBnZXRCaXNob3BNb3Zlcyhib2FyZCwgcm93LCBjb2wsIGlzV2hpdGUpOyBicmVhaztcbiAgICAgICAgY2FzZSAncSc6IG1vdmVzID0gZ2V0UXVlZW5Nb3Zlcyhib2FyZCwgcm93LCBjb2wsIGlzV2hpdGUpOyBicmVhaztcbiAgICAgICAgY2FzZSAnayc6IG1vdmVzID0gZ2V0S2luZ01vdmVzKGJvYXJkLCByb3csIGNvbCwgaXNXaGl0ZSk7IGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChjb25zaWRlclBpbikge1xuICAgICAgICBtb3ZlcyA9IG1vdmVzLmZpbHRlcigoW25ld1JvdywgbmV3Q29sXSkgPT4gIW1vdmVQdXRzT3duS2luZ0luQ2hlY2soYm9hcmQsIHJvdywgY29sLCBuZXdSb3csIG5ld0NvbCkpO1xuICAgIH1cblxuICAgIHJldHVybiBtb3Zlcztcbn1cblxuZnVuY3Rpb24gZ2V0UGF3bk1vdmVzKGJvYXJkOiBCb2FyZCwgcm93OiBudW1iZXIsIGNvbDogbnVtYmVyLCBpc1doaXRlOiBib29sZWFuKTogW251bWJlciwgbnVtYmVyXVtdIHtcbiAgICBjb25zdCBtb3ZlczogW251bWJlciwgbnVtYmVyXVtdID0gW107XG4gICAgY29uc3QgZGlyZWN0aW9uID0gaXNXaGl0ZSA/IC0xIDogMTtcbiAgICBjb25zdCBzdGFydFJvdyA9IGlzV2hpdGUgPyA2IDogMTtcblxuICAgIGlmIChib2FyZFtyb3cgKyBkaXJlY3Rpb25dPy5bY29sXSA9PT0gJycpIHtcbiAgICAgICAgbW92ZXMucHVzaChbcm93ICsgZGlyZWN0aW9uLCBjb2xdKTtcbiAgICAgICAgaWYgKHJvdyA9PT0gc3RhcnRSb3cgJiYgYm9hcmRbcm93ICsgMiAqIGRpcmVjdGlvbl0/Lltjb2xdID09PSAnJykge1xuICAgICAgICAgICAgbW92ZXMucHVzaChbcm93ICsgMiAqIGRpcmVjdGlvbiwgY29sXSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IGRjb2wgb2YgWy0xLCAxXSkge1xuICAgICAgICBpZiAoYm9hcmRbcm93ICsgZGlyZWN0aW9uXT8uW2NvbCArIGRjb2xdICYmIGlzT3Bwb25lbnRQaWVjZShib2FyZFtyb3cgKyBkaXJlY3Rpb25dW2NvbCArIGRjb2xdLCBpc1doaXRlKSkge1xuICAgICAgICAgICAgbW92ZXMucHVzaChbcm93ICsgZGlyZWN0aW9uLCBjb2wgKyBkY29sXSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbW92ZXM7XG59XG5cbmZ1bmN0aW9uIGdldFJvb2tNb3Zlcyhib2FyZDogQm9hcmQsIHJvdzogbnVtYmVyLCBjb2w6IG51bWJlciwgaXNXaGl0ZTogYm9vbGVhbik6IFtudW1iZXIsIG51bWJlcl1bXSB7XG4gICAgcmV0dXJuIGdldFN0cmFpZ2h0TW92ZXMoYm9hcmQsIHJvdywgY29sLCBpc1doaXRlKTtcbn1cblxuZnVuY3Rpb24gZ2V0S25pZ2h0TW92ZXMoYm9hcmQ6IEJvYXJkLCByb3c6IG51bWJlciwgY29sOiBudW1iZXIsIGlzV2hpdGU6IGJvb2xlYW4pOiBbbnVtYmVyLCBudW1iZXJdW10ge1xuICAgIGNvbnN0IG1vdmVzOiBbbnVtYmVyLCBudW1iZXJdW10gPSBbXTtcbiAgICBjb25zdCBrbmlnaHRNb3ZlcyA9IFtbLTIsIC0xXSwgWy0yLCAxXSwgWy0xLCAtMl0sIFstMSwgMl0sIFsxLCAtMl0sIFsxLCAyXSwgWzIsIC0xXSwgWzIsIDFdXTtcblxuICAgIGZvciAoY29uc3QgW2RyLCBkY10gb2Yga25pZ2h0TW92ZXMpIHtcbiAgICAgICAgY29uc3QgbmV3Um93ID0gcm93ICsgZHI7XG4gICAgICAgIGNvbnN0IG5ld0NvbCA9IGNvbCArIGRjO1xuICAgICAgICBpZiAoaXNWYWxpZFBvc2l0aW9uKG5ld1JvdywgbmV3Q29sKSAmJiAoYm9hcmRbbmV3Um93XVtuZXdDb2xdID09PSAnJyB8fCBpc09wcG9uZW50UGllY2UoYm9hcmRbbmV3Um93XVtuZXdDb2xdLCBpc1doaXRlKSkpIHtcbiAgICAgICAgICAgIG1vdmVzLnB1c2goW25ld1JvdywgbmV3Q29sXSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbW92ZXM7XG59XG5cbmZ1bmN0aW9uIGdldEJpc2hvcE1vdmVzKGJvYXJkOiBCb2FyZCwgcm93OiBudW1iZXIsIGNvbDogbnVtYmVyLCBpc1doaXRlOiBib29sZWFuKTogW251bWJlciwgbnVtYmVyXVtdIHtcbiAgICByZXR1cm4gZ2V0RGlhZ29uYWxNb3Zlcyhib2FyZCwgcm93LCBjb2wsIGlzV2hpdGUpO1xufVxuXG5mdW5jdGlvbiBnZXRRdWVlbk1vdmVzKGJvYXJkOiBCb2FyZCwgcm93OiBudW1iZXIsIGNvbDogbnVtYmVyLCBpc1doaXRlOiBib29sZWFuKTogW251bWJlciwgbnVtYmVyXVtdIHtcbiAgICByZXR1cm4gWy4uLmdldFN0cmFpZ2h0TW92ZXMoYm9hcmQsIHJvdywgY29sLCBpc1doaXRlKSwgLi4uZ2V0RGlhZ29uYWxNb3Zlcyhib2FyZCwgcm93LCBjb2wsIGlzV2hpdGUpXTtcbn1cblxuZnVuY3Rpb24gZ2V0S2luZ01vdmVzKGJvYXJkOiBCb2FyZCwgcm93OiBudW1iZXIsIGNvbDogbnVtYmVyLCBpc1doaXRlOiBib29sZWFuKTogW251bWJlciwgbnVtYmVyXVtdIHtcbiAgICBjb25zdCBtb3ZlczogW251bWJlciwgbnVtYmVyXVtdID0gW107XG4gICAgY29uc3Qga2luZ01vdmVzID0gW1stMSwgLTFdLCBbLTEsIDBdLCBbLTEsIDFdLCBbMCwgLTFdLCBbMCwgMV0sIFsxLCAtMV0sIFsxLCAwXSwgWzEsIDFdXTtcblxuICAgIGZvciAoY29uc3QgW2RyLCBkY10gb2Yga2luZ01vdmVzKSB7XG4gICAgICAgIGNvbnN0IG5ld1JvdyA9IHJvdyArIGRyO1xuICAgICAgICBjb25zdCBuZXdDb2wgPSBjb2wgKyBkYztcbiAgICAgICAgaWYgKGlzVmFsaWRQb3NpdGlvbihuZXdSb3csIG5ld0NvbCkgJiYgKGJvYXJkW25ld1Jvd11bbmV3Q29sXSA9PT0gJycgfHwgaXNPcHBvbmVudFBpZWNlKGJvYXJkW25ld1Jvd11bbmV3Q29sXSwgaXNXaGl0ZSkpKSB7XG4gICAgICAgICAgICBtb3Zlcy5wdXNoKFtuZXdSb3csIG5ld0NvbF0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1vdmVzO1xufVxuXG5mdW5jdGlvbiBnZXRTdHJhaWdodE1vdmVzKGJvYXJkOiBCb2FyZCwgcm93OiBudW1iZXIsIGNvbDogbnVtYmVyLCBpc1doaXRlOiBib29sZWFuKTogW251bWJlciwgbnVtYmVyXVtdIHtcbiAgICBjb25zdCBtb3ZlczogW251bWJlciwgbnVtYmVyXVtdID0gW107XG4gICAgY29uc3QgZGlyZWN0aW9ucyA9IFtbLTEsIDBdLCBbMSwgMF0sIFswLCAtMV0sIFswLCAxXV07XG5cbiAgICBmb3IgKGNvbnN0IFtkciwgZGNdIG9mIGRpcmVjdGlvbnMpIHtcbiAgICAgICAgbGV0IG5ld1JvdyA9IHJvdyArIGRyO1xuICAgICAgICBsZXQgbmV3Q29sID0gY29sICsgZGM7XG4gICAgICAgIHdoaWxlIChpc1ZhbGlkUG9zaXRpb24obmV3Um93LCBuZXdDb2wpKSB7XG4gICAgICAgICAgICBpZiAoYm9hcmRbbmV3Um93XVtuZXdDb2xdID09PSAnJykge1xuICAgICAgICAgICAgICAgIG1vdmVzLnB1c2goW25ld1JvdywgbmV3Q29sXSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzT3Bwb25lbnRQaWVjZShib2FyZFtuZXdSb3ddW25ld0NvbF0sIGlzV2hpdGUpKSB7XG4gICAgICAgICAgICAgICAgbW92ZXMucHVzaChbbmV3Um93LCBuZXdDb2xdKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdSb3cgKz0gZHI7XG4gICAgICAgICAgICBuZXdDb2wgKz0gZGM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbW92ZXM7XG59XG5cbmZ1bmN0aW9uIGdldERpYWdvbmFsTW92ZXMoYm9hcmQ6IEJvYXJkLCByb3c6IG51bWJlciwgY29sOiBudW1iZXIsIGlzV2hpdGU6IGJvb2xlYW4pOiBbbnVtYmVyLCBudW1iZXJdW10ge1xuICAgIGNvbnN0IG1vdmVzOiBbbnVtYmVyLCBudW1iZXJdW10gPSBbXTtcbiAgICBjb25zdCBkaXJlY3Rpb25zID0gW1stMSwgLTFdLCBbLTEsIDFdLCBbMSwgLTFdLCBbMSwgMV1dO1xuXG4gICAgZm9yIChjb25zdCBbZHIsIGRjXSBvZiBkaXJlY3Rpb25zKSB7XG4gICAgICAgIGxldCBuZXdSb3cgPSByb3cgKyBkcjtcbiAgICAgICAgbGV0IG5ld0NvbCA9IGNvbCArIGRjO1xuICAgICAgICB3aGlsZSAoaXNWYWxpZFBvc2l0aW9uKG5ld1JvdywgbmV3Q29sKSkge1xuICAgICAgICAgICAgaWYgKGJvYXJkW25ld1Jvd11bbmV3Q29sXSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICBtb3Zlcy5wdXNoKFtuZXdSb3csIG5ld0NvbF0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpc09wcG9uZW50UGllY2UoYm9hcmRbbmV3Um93XVtuZXdDb2xdLCBpc1doaXRlKSkge1xuICAgICAgICAgICAgICAgIG1vdmVzLnB1c2goW25ld1JvdywgbmV3Q29sXSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3Um93ICs9IGRyO1xuICAgICAgICAgICAgbmV3Q29sICs9IGRjO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1vdmVzO1xufVxuXG5mdW5jdGlvbiBpc1ZhbGlkUG9zaXRpb24ocm93OiBudW1iZXIsIGNvbDogbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHJvdyA+PSAwICYmIHJvdyA8IDggJiYgY29sID49IDAgJiYgY29sIDwgODtcbn1cblxuZnVuY3Rpb24gaXNPcHBvbmVudFBpZWNlKHBpZWNlOiBQaWVjZSwgaXNXaGl0ZTogYm9vbGVhbik6IGJvb2xlYW4ge1xuICAgIHJldHVybiBwaWVjZSAhPT0gJycgJiYgKGlzV2hpdGUgPyBwaWVjZSA9PT0gcGllY2UudG9Mb3dlckNhc2UoKSA6IHBpZWNlID09PSBwaWVjZS50b1VwcGVyQ2FzZSgpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzQ2hlY2soYm9hcmQ6IEJvYXJkLCBpc1doaXRlS2luZzogYm9vbGVhbik6IGJvb2xlYW4ge1xuICAgIGNvbnN0IGtpbmdQaWVjZSA9IGlzV2hpdGVLaW5nID8gJ0snIDogJ2snO1xuICAgIGxldCBraW5nUm93ID0gLTEsIGtpbmdDb2wgPSAtMTtcblxuICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IDg7IHJvdysrKSB7XG4gICAgICAgIGZvciAobGV0IGNvbCA9IDA7IGNvbCA8IDg7IGNvbCsrKSB7XG4gICAgICAgICAgICBpZiAoYm9hcmRbcm93XVtjb2xdID09PSBraW5nUGllY2UpIHtcbiAgICAgICAgICAgICAgICBraW5nUm93ID0gcm93O1xuICAgICAgICAgICAgICAgIGtpbmdDb2wgPSBjb2w7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGtpbmdSb3cgIT09IC0xKSBicmVhaztcbiAgICB9XG5cbiAgICBmb3IgKGxldCByb3cgPSAwOyByb3cgPCA4OyByb3crKykge1xuICAgICAgICBmb3IgKGxldCBjb2wgPSAwOyBjb2wgPCA4OyBjb2wrKykge1xuICAgICAgICAgICAgaWYgKGJvYXJkW3Jvd11bY29sXSAhPT0gJycgJiYgaXNPcHBvbmVudFBpZWNlKGJvYXJkW3Jvd11bY29sXSwgaXNXaGl0ZUtpbmcpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbW92ZXMgPSBnZXRWYWxpZE1vdmVzKGJvYXJkLCByb3csIGNvbCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIGlmIChtb3Zlcy5zb21lKChbciwgY10pID0+IHIgPT09IGtpbmdSb3cgJiYgYyA9PT0ga2luZ0NvbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNDaGVja21hdGUoYm9hcmQ6IEJvYXJkLCBpc1doaXRlS2luZzogYm9vbGVhbik6IGJvb2xlYW4ge1xuICAgIGlmICghaXNDaGVjayhib2FyZCwgaXNXaGl0ZUtpbmcpKSByZXR1cm4gZmFsc2U7XG5cbiAgICBmb3IgKGxldCByb3cgPSAwOyByb3cgPCA4OyByb3crKykge1xuICAgICAgICBmb3IgKGxldCBjb2wgPSAwOyBjb2wgPCA4OyBjb2wrKykge1xuICAgICAgICAgICAgY29uc3QgcGllY2UgPSBib2FyZFtyb3ddW2NvbF07XG4gICAgICAgICAgICBpZiAocGllY2UgIT09ICcnICYmIChpc1doaXRlS2luZyA/IHBpZWNlID09PSBwaWVjZS50b1VwcGVyQ2FzZSgpIDogcGllY2UgPT09IHBpZWNlLnRvTG93ZXJDYXNlKCkpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbW92ZXMgPSBnZXRWYWxpZE1vdmVzKGJvYXJkLCByb3csIGNvbCk7XG4gICAgICAgICAgICAgICAgaWYgKG1vdmVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBtb3ZlUHV0c093bktpbmdJbkNoZWNrKGJvYXJkOiBCb2FyZCwgZnJvbVJvdzogbnVtYmVyLCBmcm9tQ29sOiBudW1iZXIsIHRvUm93OiBudW1iZXIsIHRvQ29sOiBudW1iZXIpOiBib29sZWFuIHtcbiAgICBjb25zdCBuZXdCb2FyZCA9IGJvYXJkLm1hcChyb3cgPT4gWy4uLnJvd10pO1xuICAgIG5ld0JvYXJkW3RvUm93XVt0b0NvbF0gPSBuZXdCb2FyZFtmcm9tUm93XVtmcm9tQ29sXTtcbiAgICBuZXdCb2FyZFtmcm9tUm93XVtmcm9tQ29sXSA9ICcnO1xuICAgIHJldHVybiBpc0NoZWNrKG5ld0JvYXJkLCBuZXdCb2FyZFt0b1Jvd11bdG9Db2xdID09PSBuZXdCb2FyZFt0b1Jvd11bdG9Db2xdLnRvVXBwZXJDYXNlKCkpO1xufVxuXG4iXSwibmFtZXMiOlsiZ2V0VmFsaWRNb3ZlcyIsImJvYXJkIiwicm93IiwiY29sIiwiY29uc2lkZXJQaW4iLCJwaWVjZSIsImlzV2hpdGUiLCJ0b1VwcGVyQ2FzZSIsIm1vdmVzIiwidG9Mb3dlckNhc2UiLCJnZXRQYXduTW92ZXMiLCJnZXRSb29rTW92ZXMiLCJnZXRLbmlnaHRNb3ZlcyIsImdldEJpc2hvcE1vdmVzIiwiZ2V0UXVlZW5Nb3ZlcyIsImdldEtpbmdNb3ZlcyIsImZpbHRlciIsIm5ld1JvdyIsIm5ld0NvbCIsIm1vdmVQdXRzT3duS2luZ0luQ2hlY2siLCJkaXJlY3Rpb24iLCJzdGFydFJvdyIsInB1c2giLCJkY29sIiwiaXNPcHBvbmVudFBpZWNlIiwiZ2V0U3RyYWlnaHRNb3ZlcyIsImtuaWdodE1vdmVzIiwiZHIiLCJkYyIsImlzVmFsaWRQb3NpdGlvbiIsImdldERpYWdvbmFsTW92ZXMiLCJraW5nTW92ZXMiLCJkaXJlY3Rpb25zIiwiaXNDaGVjayIsImlzV2hpdGVLaW5nIiwia2luZ1BpZWNlIiwia2luZ1JvdyIsImtpbmdDb2wiLCJzb21lIiwiciIsImMiLCJpc0NoZWNrbWF0ZSIsImxlbmd0aCIsImZyb21Sb3ciLCJmcm9tQ29sIiwidG9Sb3ciLCJ0b0NvbCIsIm5ld0JvYXJkIiwibWFwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./chessLogic.ts\n"));

/***/ })

});