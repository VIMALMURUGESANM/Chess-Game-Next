"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./chessLogic.ts":
/*!***********************!*\
  !*** ./chessLogic.ts ***!
  \***********************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getValidMoves: function() { return /* binding */ getValidMoves; },\n/* harmony export */   isCheck: function() { return /* binding */ isCheck; },\n/* harmony export */   isCheckmate: function() { return /* binding */ isCheckmate; }\n/* harmony export */ });\nfunction getValidMoves(board, row, col) {\n    let considerPin = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true, canCastleKingside = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false, canCastleQueenside = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : false;\n    const piece = board[row][col];\n    const isWhite = piece === piece.toUpperCase();\n    let moves = [];\n    switch(piece.toLowerCase()){\n        case \"p\":\n            moves = getPawnMoves(board, row, col, isWhite);\n            break;\n        case \"r\":\n            moves = getRookMoves(board, row, col, isWhite);\n            break;\n        case \"n\":\n            moves = getKnightMoves(board, row, col, isWhite);\n            break;\n        case \"b\":\n            moves = getBishopMoves(board, row, col, isWhite);\n            break;\n        case \"q\":\n            moves = getQueenMoves(board, row, col, isWhite);\n            break;\n        case \"k\":\n            moves = getKingMoves(board, row, col, isWhite, canCastleKingside, canCastleQueenside);\n            break;\n    }\n    if (considerPin) {\n        moves = moves.filter((param)=>{\n            let [newRow, newCol] = param;\n            return !movePutsOwnKingInCheck(board, row, col, newRow, newCol, isWhite);\n        });\n    }\n    return moves;\n}\nfunction getPawnMoves(board, row, col, isWhite) {\n    var _board_;\n    const moves = [];\n    const direction = isWhite ? -1 : 1;\n    const startRow = isWhite ? 6 : 1;\n    if (((_board_ = board[row + direction]) === null || _board_ === void 0 ? void 0 : _board_[col]) === \"\") {\n        var _board_1;\n        moves.push([\n            row + direction,\n            col\n        ]);\n        if (row === startRow && ((_board_1 = board[row + 2 * direction]) === null || _board_1 === void 0 ? void 0 : _board_1[col]) === \"\") {\n            moves.push([\n                row + 2 * direction,\n                col\n            ]);\n        }\n    }\n    for (const dcol of [\n        -1,\n        1\n    ]){\n        var _board_2;\n        if (((_board_2 = board[row + direction]) === null || _board_2 === void 0 ? void 0 : _board_2[col + dcol]) && isOpponentPiece(board[row + direction][col + dcol], isWhite)) {\n            moves.push([\n                row + direction,\n                col + dcol\n            ]);\n        }\n    }\n    return moves;\n}\nfunction getRookMoves(board, row, col, isWhite) {\n    return getStraightMoves(board, row, col, isWhite);\n}\nfunction getKnightMoves(board, row, col, isWhite) {\n    const moves = [];\n    const knightMoves = [\n        [\n            -2,\n            -1\n        ],\n        [\n            -2,\n            1\n        ],\n        [\n            -1,\n            -2\n        ],\n        [\n            -1,\n            2\n        ],\n        [\n            1,\n            -2\n        ],\n        [\n            1,\n            2\n        ],\n        [\n            2,\n            -1\n        ],\n        [\n            2,\n            1\n        ]\n    ];\n    for (const [dr, dc] of knightMoves){\n        const newRow = row + dr;\n        const newCol = col + dc;\n        if (isValidPosition(newRow, newCol) && (board[newRow][newCol] === \"\" || isOpponentPiece(board[newRow][newCol], isWhite))) {\n            moves.push([\n                newRow,\n                newCol\n            ]);\n        }\n    }\n    return moves;\n}\nfunction getBishopMoves(board, row, col, isWhite) {\n    return getDiagonalMoves(board, row, col, isWhite);\n}\nfunction getQueenMoves(board, row, col, isWhite) {\n    return [\n        ...getStraightMoves(board, row, col, isWhite),\n        ...getDiagonalMoves(board, row, col, isWhite)\n    ];\n}\nfunction getKingMoves(board, row, col, isWhite, canCastleKingside, canCastleQueenside) {\n    const moves = [];\n    const kingMoves = [\n        [\n            -1,\n            -1\n        ],\n        [\n            -1,\n            0\n        ],\n        [\n            -1,\n            1\n        ],\n        [\n            0,\n            -1\n        ],\n        [\n            0,\n            1\n        ],\n        [\n            1,\n            -1\n        ],\n        [\n            1,\n            0\n        ],\n        [\n            1,\n            1\n        ]\n    ];\n    for (const [dr, dc] of kingMoves){\n        const newRow = row + dr;\n        const newCol = col + dc;\n        if (isValidPosition(newRow, newCol) && (board[newRow][newCol] === \"\" || isOpponentPiece(board[newRow][newCol], isWhite))) {\n            moves.push([\n                newRow,\n                newCol\n            ]);\n        }\n    }\n    moves.push(...getCastlingMoves(board, row, col, isWhite, canCastleKingside, canCastleQueenside));\n    return moves;\n}\nfunction getCastlingMoves(board, row, col, isWhite, canCastleKingside, canCastleQueenside) {\n    const castlingMoves = [];\n    if (isCheck(board, isWhite)) return castlingMoves;\n    const backRank = isWhite ? 7 : 0;\n    if (canCastleKingside && board[backRank][5] === \"\" && board[backRank][6] === \"\") {\n        if (!isSquareUnderAttack(board, backRank, 4, isWhite) && !isSquareUnderAttack(board, backRank, 5, isWhite) && !isSquareUnderAttack(board, backRank, 6, isWhite)) {\n            castlingMoves.push([\n                backRank,\n                6\n            ]);\n        }\n    }\n    if (canCastleQueenside && board[backRank][1] === \"\" && board[backRank][2] === \"\" && board[backRank][3] === \"\") {\n        if (!isSquareUnderAttack(board, backRank, 4, isWhite) && !isSquareUnderAttack(board, backRank, 3, isWhite) && !isSquareUnderAttack(board, backRank, 2, isWhite)) {\n            castlingMoves.push([\n                backRank,\n                2\n            ]);\n        }\n    }\n    return castlingMoves;\n}\nfunction isSquareUnderAttack(board, row, col, isWhite) {\n    const opponentColor = isWhite ? \"b\" : \"w\";\n    const directions = [\n        [\n            -1,\n            -1\n        ],\n        [\n            -1,\n            0\n        ],\n        [\n            -1,\n            1\n        ],\n        [\n            0,\n            -1\n        ],\n        [\n            0,\n            1\n        ],\n        [\n            1,\n            -1\n        ],\n        [\n            1,\n            0\n        ],\n        [\n            1,\n            1\n        ]\n    ];\n    // Check for pawn attacks\n    const pawnDirection = isWhite ? 1 : -1;\n    if (isValidPosition(row + pawnDirection, col - 1) && board[row + pawnDirection][col - 1].toLowerCase() === \"p\" && isOpponentPiece(board[row + pawnDirection][col - 1], isWhite)) return true;\n    if (isValidPosition(row + pawnDirection, col + 1) && board[row + pawnDirection][col + 1].toLowerCase() === \"p\" && isOpponentPiece(board[row + pawnDirection][col + 1], isWhite)) return true;\n    // Check for knight attacks\n    const knightMoves = [\n        [\n            -2,\n            -1\n        ],\n        [\n            -2,\n            1\n        ],\n        [\n            -1,\n            -2\n        ],\n        [\n            -1,\n            2\n        ],\n        [\n            1,\n            -2\n        ],\n        [\n            1,\n            2\n        ],\n        [\n            2,\n            -1\n        ],\n        [\n            2,\n            1\n        ]\n    ];\n    for (const [dr, dc] of knightMoves){\n        const newRow = row + dr;\n        const newCol = col + dc;\n        if (isValidPosition(newRow, newCol) && board[newRow][newCol].toLowerCase() === \"n\" && isOpponentPiece(board[newRow][newCol], isWhite)) return true;\n    }\n    // Check for attacks from other pieces (rook, bishop, queen, king)\n    for (const [dr, dc] of directions){\n        let newRow = row + dr;\n        let newCol = col + dc;\n        let distance = 1;\n        while(isValidPosition(newRow, newCol)){\n            const piece = board[newRow][newCol].toLowerCase();\n            if (piece !== \"\") {\n                if (isOpponentPiece(board[newRow][newCol], isWhite)) {\n                    if (piece === \"q\" || piece === \"r\" && (dr === 0 || dc === 0) || piece === \"b\" && dr !== 0 && dc !== 0 || piece === \"k\" && distance === 1) {\n                        return true;\n                    }\n                }\n                break;\n            }\n            newRow += dr;\n            newCol += dc;\n            distance++;\n        }\n    }\n    return false;\n}\nfunction getStraightMoves(board, row, col, isWhite) {\n    const moves = [];\n    const directions = [\n        [\n            -1,\n            0\n        ],\n        [\n            1,\n            0\n        ],\n        [\n            0,\n            -1\n        ],\n        [\n            0,\n            1\n        ]\n    ];\n    for (const [dr, dc] of directions){\n        let newRow = row + dr;\n        let newCol = col + dc;\n        while(isValidPosition(newRow, newCol)){\n            if (board[newRow][newCol] === \"\") {\n                moves.push([\n                    newRow,\n                    newCol\n                ]);\n            } else if (isOpponentPiece(board[newRow][newCol], isWhite)) {\n                moves.push([\n                    newRow,\n                    newCol\n                ]);\n                break;\n            } else {\n                break;\n            }\n            newRow += dr;\n            newCol += dc;\n        }\n    }\n    return moves;\n}\nfunction getDiagonalMoves(board, row, col, isWhite) {\n    const moves = [];\n    const directions = [\n        [\n            -1,\n            -1\n        ],\n        [\n            -1,\n            1\n        ],\n        [\n            1,\n            -1\n        ],\n        [\n            1,\n            1\n        ]\n    ];\n    for (const [dr, dc] of directions){\n        let newRow = row + dr;\n        let newCol = col + dc;\n        while(isValidPosition(newRow, newCol)){\n            if (board[newRow][newCol] === \"\") {\n                moves.push([\n                    newRow,\n                    newCol\n                ]);\n            } else if (isOpponentPiece(board[newRow][newCol], isWhite)) {\n                moves.push([\n                    newRow,\n                    newCol\n                ]);\n                break;\n            } else {\n                break;\n            }\n            newRow += dr;\n            newCol += dc;\n        }\n    }\n    return moves;\n}\nfunction isValidPosition(row, col) {\n    return row >= 0 && row < 8 && col >= 0 && col < 8;\n}\nfunction isOpponentPiece(piece, isWhite) {\n    return piece !== \"\" && (isWhite ? piece === piece.toLowerCase() : piece === piece.toUpperCase());\n}\nfunction isCheck(board, isWhiteKing) {\n    const kingPiece = isWhiteKing ? \"K\" : \"k\";\n    for(let row = 0; row < 8; row++){\n        for(let col = 0; col < 8; col++){\n            if (board[row][col] === kingPiece) {\n                return isSquareUnderAttack(board, row, col, isWhiteKing);\n            }\n        }\n    }\n    return false; // This should never happen in a valid chess position\n}\nfunction isCheckmate(board, isWhiteKing) {\n    if (!isCheck(board, isWhiteKing)) return false;\n    for(let row = 0; row < 8; row++){\n        for(let col = 0; col < 8; col++){\n            const piece = board[row][col];\n            if (piece !== \"\" && (isWhiteKing ? piece === piece.toUpperCase() : piece === piece.toLowerCase())) {\n                const moves = getValidMoves(board, row, col, true, false, false);\n                if (moves.length > 0) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}\nfunction movePutsOwnKingInCheck(board, fromRow, fromCol, toRow, toCol, isWhite) {\n    const newBoard = board.map((row)=>[\n            ...row\n        ]);\n    newBoard[toRow][toCol] = newBoard[fromRow][fromCol];\n    newBoard[fromRow][fromCol] = \"\";\n    return isCheck(newBoard, isWhite);\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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InNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9jaGVzc0xvZ2ljLnRzPzIwNjciXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHR5cGUgUGllY2UgPSAncCcgfCAncicgfCAnbicgfCAnYicgfCAncScgfCAnaycgfCAnUCcgfCAnUicgfCAnTicgfCAnQicgfCAnUScgfCAnSycgfCAnJztcbmV4cG9ydCB0eXBlIEJvYXJkID0gUGllY2VbXVtdO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0VmFsaWRNb3ZlcyhcbiAgICBib2FyZDogQm9hcmQsXG4gICAgcm93OiBudW1iZXIsXG4gICAgY29sOiBudW1iZXIsXG4gICAgY29uc2lkZXJQaW46IGJvb2xlYW4gPSB0cnVlLFxuICAgIGNhbkNhc3RsZUtpbmdzaWRlOiBib29sZWFuID0gZmFsc2UsXG4gICAgY2FuQ2FzdGxlUXVlZW5zaWRlOiBib29sZWFuID0gZmFsc2Vcbik6IFtudW1iZXIsIG51bWJlcl1bXSB7XG4gICAgY29uc3QgcGllY2UgPSBib2FyZFtyb3ddW2NvbF07XG4gICAgY29uc3QgaXNXaGl0ZSA9IHBpZWNlID09PSBwaWVjZS50b1VwcGVyQ2FzZSgpO1xuICAgIGxldCBtb3ZlczogW251bWJlciwgbnVtYmVyXVtdID0gW107XG5cbiAgICBzd2l0Y2ggKHBpZWNlLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgY2FzZSAncCc6IG1vdmVzID0gZ2V0UGF3bk1vdmVzKGJvYXJkLCByb3csIGNvbCwgaXNXaGl0ZSk7IGJyZWFrO1xuICAgICAgICBjYXNlICdyJzogbW92ZXMgPSBnZXRSb29rTW92ZXMoYm9hcmQsIHJvdywgY29sLCBpc1doaXRlKTsgYnJlYWs7XG4gICAgICAgIGNhc2UgJ24nOiBtb3ZlcyA9IGdldEtuaWdodE1vdmVzKGJvYXJkLCByb3csIGNvbCwgaXNXaGl0ZSk7IGJyZWFrO1xuICAgICAgICBjYXNlICdiJzogbW92ZXMgPSBnZXRCaXNob3BNb3Zlcyhib2FyZCwgcm93LCBjb2wsIGlzV2hpdGUpOyBicmVhaztcbiAgICAgICAgY2FzZSAncSc6IG1vdmVzID0gZ2V0UXVlZW5Nb3Zlcyhib2FyZCwgcm93LCBjb2wsIGlzV2hpdGUpOyBicmVhaztcbiAgICAgICAgY2FzZSAnayc6IG1vdmVzID0gZ2V0S2luZ01vdmVzKGJvYXJkLCByb3csIGNvbCwgaXNXaGl0ZSwgY2FuQ2FzdGxlS2luZ3NpZGUsIGNhbkNhc3RsZVF1ZWVuc2lkZSk7IGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChjb25zaWRlclBpbikge1xuICAgICAgICBtb3ZlcyA9IG1vdmVzLmZpbHRlcigoW25ld1JvdywgbmV3Q29sXSkgPT4gIW1vdmVQdXRzT3duS2luZ0luQ2hlY2soYm9hcmQsIHJvdywgY29sLCBuZXdSb3csIG5ld0NvbCwgaXNXaGl0ZSkpO1xuICAgIH1cblxuICAgIHJldHVybiBtb3Zlcztcbn1cblxuZnVuY3Rpb24gZ2V0UGF3bk1vdmVzKGJvYXJkOiBCb2FyZCwgcm93OiBudW1iZXIsIGNvbDogbnVtYmVyLCBpc1doaXRlOiBib29sZWFuKTogW251bWJlciwgbnVtYmVyXVtdIHtcbiAgICBjb25zdCBtb3ZlczogW251bWJlciwgbnVtYmVyXVtdID0gW107XG4gICAgY29uc3QgZGlyZWN0aW9uID0gaXNXaGl0ZSA/IC0xIDogMTtcbiAgICBjb25zdCBzdGFydFJvdyA9IGlzV2hpdGUgPyA2IDogMTtcblxuICAgIGlmIChib2FyZFtyb3cgKyBkaXJlY3Rpb25dPy5bY29sXSA9PT0gJycpIHtcbiAgICAgICAgbW92ZXMucHVzaChbcm93ICsgZGlyZWN0aW9uLCBjb2xdKTtcbiAgICAgICAgaWYgKHJvdyA9PT0gc3RhcnRSb3cgJiYgYm9hcmRbcm93ICsgMiAqIGRpcmVjdGlvbl0/Lltjb2xdID09PSAnJykge1xuICAgICAgICAgICAgbW92ZXMucHVzaChbcm93ICsgMiAqIGRpcmVjdGlvbiwgY29sXSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IGRjb2wgb2YgWy0xLCAxXSkge1xuICAgICAgICBpZiAoYm9hcmRbcm93ICsgZGlyZWN0aW9uXT8uW2NvbCArIGRjb2xdICYmIGlzT3Bwb25lbnRQaWVjZShib2FyZFtyb3cgKyBkaXJlY3Rpb25dW2NvbCArIGRjb2xdLCBpc1doaXRlKSkge1xuICAgICAgICAgICAgbW92ZXMucHVzaChbcm93ICsgZGlyZWN0aW9uLCBjb2wgKyBkY29sXSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbW92ZXM7XG59XG5cbmZ1bmN0aW9uIGdldFJvb2tNb3Zlcyhib2FyZDogQm9hcmQsIHJvdzogbnVtYmVyLCBjb2w6IG51bWJlciwgaXNXaGl0ZTogYm9vbGVhbik6IFtudW1iZXIsIG51bWJlcl1bXSB7XG4gICAgcmV0dXJuIGdldFN0cmFpZ2h0TW92ZXMoYm9hcmQsIHJvdywgY29sLCBpc1doaXRlKTtcbn1cblxuZnVuY3Rpb24gZ2V0S25pZ2h0TW92ZXMoYm9hcmQ6IEJvYXJkLCByb3c6IG51bWJlciwgY29sOiBudW1iZXIsIGlzV2hpdGU6IGJvb2xlYW4pOiBbbnVtYmVyLCBudW1iZXJdW10ge1xuICAgIGNvbnN0IG1vdmVzOiBbbnVtYmVyLCBudW1iZXJdW10gPSBbXTtcbiAgICBjb25zdCBrbmlnaHRNb3ZlcyA9IFtbLTIsIC0xXSwgWy0yLCAxXSwgWy0xLCAtMl0sIFstMSwgMl0sIFsxLCAtMl0sIFsxLCAyXSwgWzIsIC0xXSwgWzIsIDFdXTtcblxuICAgIGZvciAoY29uc3QgW2RyLCBkY10gb2Yga25pZ2h0TW92ZXMpIHtcbiAgICAgICAgY29uc3QgbmV3Um93ID0gcm93ICsgZHI7XG4gICAgICAgIGNvbnN0IG5ld0NvbCA9IGNvbCArIGRjO1xuICAgICAgICBpZiAoaXNWYWxpZFBvc2l0aW9uKG5ld1JvdywgbmV3Q29sKSAmJiAoYm9hcmRbbmV3Um93XVtuZXdDb2xdID09PSAnJyB8fCBpc09wcG9uZW50UGllY2UoYm9hcmRbbmV3Um93XVtuZXdDb2xdLCBpc1doaXRlKSkpIHtcbiAgICAgICAgICAgIG1vdmVzLnB1c2goW25ld1JvdywgbmV3Q29sXSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbW92ZXM7XG59XG5cbmZ1bmN0aW9uIGdldEJpc2hvcE1vdmVzKGJvYXJkOiBCb2FyZCwgcm93OiBudW1iZXIsIGNvbDogbnVtYmVyLCBpc1doaXRlOiBib29sZWFuKTogW251bWJlciwgbnVtYmVyXVtdIHtcbiAgICByZXR1cm4gZ2V0RGlhZ29uYWxNb3Zlcyhib2FyZCwgcm93LCBjb2wsIGlzV2hpdGUpO1xufVxuXG5mdW5jdGlvbiBnZXRRdWVlbk1vdmVzKGJvYXJkOiBCb2FyZCwgcm93OiBudW1iZXIsIGNvbDogbnVtYmVyLCBpc1doaXRlOiBib29sZWFuKTogW251bWJlciwgbnVtYmVyXVtdIHtcbiAgICByZXR1cm4gWy4uLmdldFN0cmFpZ2h0TW92ZXMoYm9hcmQsIHJvdywgY29sLCBpc1doaXRlKSwgLi4uZ2V0RGlhZ29uYWxNb3Zlcyhib2FyZCwgcm93LCBjb2wsIGlzV2hpdGUpXTtcbn1cblxuZnVuY3Rpb24gZ2V0S2luZ01vdmVzKGJvYXJkOiBCb2FyZCwgcm93OiBudW1iZXIsIGNvbDogbnVtYmVyLCBpc1doaXRlOiBib29sZWFuLCBjYW5DYXN0bGVLaW5nc2lkZTogYm9vbGVhbiwgY2FuQ2FzdGxlUXVlZW5zaWRlOiBib29sZWFuKTogW251bWJlciwgbnVtYmVyXVtdIHtcbiAgICBjb25zdCBtb3ZlczogW251bWJlciwgbnVtYmVyXVtdID0gW107XG4gICAgY29uc3Qga2luZ01vdmVzID0gW1stMSwgLTFdLCBbLTEsIDBdLCBbLTEsIDFdLCBbMCwgLTFdLCBbMCwgMV0sIFsxLCAtMV0sIFsxLCAwXSwgWzEsIDFdXTtcblxuICAgIGZvciAoY29uc3QgW2RyLCBkY10gb2Yga2luZ01vdmVzKSB7XG4gICAgICAgIGNvbnN0IG5ld1JvdyA9IHJvdyArIGRyO1xuICAgICAgICBjb25zdCBuZXdDb2wgPSBjb2wgKyBkYztcbiAgICAgICAgaWYgKGlzVmFsaWRQb3NpdGlvbihuZXdSb3csIG5ld0NvbCkgJiYgKGJvYXJkW25ld1Jvd11bbmV3Q29sXSA9PT0gJycgfHwgaXNPcHBvbmVudFBpZWNlKGJvYXJkW25ld1Jvd11bbmV3Q29sXSwgaXNXaGl0ZSkpKSB7XG4gICAgICAgICAgICBtb3Zlcy5wdXNoKFtuZXdSb3csIG5ld0NvbF0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbW92ZXMucHVzaCguLi5nZXRDYXN0bGluZ01vdmVzKGJvYXJkLCByb3csIGNvbCwgaXNXaGl0ZSwgY2FuQ2FzdGxlS2luZ3NpZGUsIGNhbkNhc3RsZVF1ZWVuc2lkZSkpO1xuXG4gICAgcmV0dXJuIG1vdmVzO1xufVxuXG5mdW5jdGlvbiBnZXRDYXN0bGluZ01vdmVzKGJvYXJkOiBCb2FyZCwgcm93OiBudW1iZXIsIGNvbDogbnVtYmVyLCBpc1doaXRlOiBib29sZWFuLCBjYW5DYXN0bGVLaW5nc2lkZTogYm9vbGVhbiwgY2FuQ2FzdGxlUXVlZW5zaWRlOiBib29sZWFuKTogW251bWJlciwgbnVtYmVyXVtdIHtcbiAgICBjb25zdCBjYXN0bGluZ01vdmVzOiBbbnVtYmVyLCBudW1iZXJdW10gPSBbXTtcbiAgICBcbiAgICBpZiAoaXNDaGVjayhib2FyZCwgaXNXaGl0ZSkpIHJldHVybiBjYXN0bGluZ01vdmVzO1xuXG4gICAgY29uc3QgYmFja1JhbmsgPSBpc1doaXRlID8gNyA6IDA7XG4gICAgXG4gICAgaWYgKGNhbkNhc3RsZUtpbmdzaWRlICYmIGJvYXJkW2JhY2tSYW5rXVs1XSA9PT0gJycgJiYgYm9hcmRbYmFja1JhbmtdWzZdID09PSAnJykge1xuICAgICAgICBpZiAoIWlzU3F1YXJlVW5kZXJBdHRhY2soYm9hcmQsIGJhY2tSYW5rLCA0LCBpc1doaXRlKSAmJlxuICAgICAgICAgICAgIWlzU3F1YXJlVW5kZXJBdHRhY2soYm9hcmQsIGJhY2tSYW5rLCA1LCBpc1doaXRlKSAmJlxuICAgICAgICAgICAgIWlzU3F1YXJlVW5kZXJBdHRhY2soYm9hcmQsIGJhY2tSYW5rLCA2LCBpc1doaXRlKSkge1xuICAgICAgICAgICAgY2FzdGxpbmdNb3Zlcy5wdXNoKFtiYWNrUmFuaywgNl0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIGlmIChjYW5DYXN0bGVRdWVlbnNpZGUgJiYgYm9hcmRbYmFja1JhbmtdWzFdID09PSAnJyAmJiBib2FyZFtiYWNrUmFua11bMl0gPT09ICcnICYmIGJvYXJkW2JhY2tSYW5rXVszXSA9PT0gJycpIHtcbiAgICAgICAgaWYgKCFpc1NxdWFyZVVuZGVyQXR0YWNrKGJvYXJkLCBiYWNrUmFuaywgNCwgaXNXaGl0ZSkgJiZcbiAgICAgICAgICAgICFpc1NxdWFyZVVuZGVyQXR0YWNrKGJvYXJkLCBiYWNrUmFuaywgMywgaXNXaGl0ZSkgJiZcbiAgICAgICAgICAgICFpc1NxdWFyZVVuZGVyQXR0YWNrKGJvYXJkLCBiYWNrUmFuaywgMiwgaXNXaGl0ZSkpIHtcbiAgICAgICAgICAgIGNhc3RsaW5nTW92ZXMucHVzaChbYmFja1JhbmssIDJdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBcbiAgICByZXR1cm4gY2FzdGxpbmdNb3Zlcztcbn1cblxuZnVuY3Rpb24gaXNTcXVhcmVVbmRlckF0dGFjayhib2FyZDogQm9hcmQsIHJvdzogbnVtYmVyLCBjb2w6IG51bWJlciwgaXNXaGl0ZTogYm9vbGVhbik6IGJvb2xlYW4ge1xuICAgIGNvbnN0IG9wcG9uZW50Q29sb3IgPSBpc1doaXRlID8gJ2InIDogJ3cnO1xuICAgIGNvbnN0IGRpcmVjdGlvbnMgPSBbXG4gICAgICAgIFstMSwgLTFdLCBbLTEsIDBdLCBbLTEsIDFdLFxuICAgICAgICBbMCwgLTFdLCAgICAgICAgICAgWzAsIDFdLFxuICAgICAgICBbMSwgLTFdLCAgWzEsIDBdLCAgWzEsIDFdXG4gICAgXTtcbiAgICBcbiAgICAvLyBDaGVjayBmb3IgcGF3biBhdHRhY2tzXG4gICAgY29uc3QgcGF3bkRpcmVjdGlvbiA9IGlzV2hpdGUgPyAxIDogLTE7XG4gICAgaWYgKGlzVmFsaWRQb3NpdGlvbihyb3cgKyBwYXduRGlyZWN0aW9uLCBjb2wgLSAxKSAmJiBib2FyZFtyb3cgKyBwYXduRGlyZWN0aW9uXVtjb2wgLSAxXS50b0xvd2VyQ2FzZSgpID09PSAncCcgJiYgaXNPcHBvbmVudFBpZWNlKGJvYXJkW3JvdyArIHBhd25EaXJlY3Rpb25dW2NvbCAtIDFdLCBpc1doaXRlKSkgcmV0dXJuIHRydWU7XG4gICAgaWYgKGlzVmFsaWRQb3NpdGlvbihyb3cgKyBwYXduRGlyZWN0aW9uLCBjb2wgKyAxKSAmJiBib2FyZFtyb3cgKyBwYXduRGlyZWN0aW9uXVtjb2wgKyAxXS50b0xvd2VyQ2FzZSgpID09PSAncCcgJiYgaXNPcHBvbmVudFBpZWNlKGJvYXJkW3JvdyArIHBhd25EaXJlY3Rpb25dW2NvbCArIDFdLCBpc1doaXRlKSkgcmV0dXJuIHRydWU7XG5cbiAgICAvLyBDaGVjayBmb3Iga25pZ2h0IGF0dGFja3NcbiAgICBjb25zdCBrbmlnaHRNb3ZlcyA9IFtbLTIsIC0xXSwgWy0yLCAxXSwgWy0xLCAtMl0sIFstMSwgMl0sIFsxLCAtMl0sIFsxLCAyXSwgWzIsIC0xXSwgWzIsIDFdXTtcbiAgICBmb3IgKGNvbnN0IFtkciwgZGNdIG9mIGtuaWdodE1vdmVzKSB7XG4gICAgICAgIGNvbnN0IG5ld1JvdyA9IHJvdyArIGRyO1xuICAgICAgICBjb25zdCBuZXdDb2wgPSBjb2wgKyBkYztcbiAgICAgICAgaWYgKGlzVmFsaWRQb3NpdGlvbihuZXdSb3csIG5ld0NvbCkgJiYgYm9hcmRbbmV3Um93XVtuZXdDb2xdLnRvTG93ZXJDYXNlKCkgPT09ICduJyAmJiBpc09wcG9uZW50UGllY2UoYm9hcmRbbmV3Um93XVtuZXdDb2xdLCBpc1doaXRlKSkgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgZm9yIGF0dGFja3MgZnJvbSBvdGhlciBwaWVjZXMgKHJvb2ssIGJpc2hvcCwgcXVlZW4sIGtpbmcpXG4gICAgZm9yIChjb25zdCBbZHIsIGRjXSBvZiBkaXJlY3Rpb25zKSB7XG4gICAgICAgIGxldCBuZXdSb3cgPSByb3cgKyBkcjtcbiAgICAgICAgbGV0IG5ld0NvbCA9IGNvbCArIGRjO1xuICAgICAgICBsZXQgZGlzdGFuY2UgPSAxO1xuICAgICAgICBcbiAgICAgICAgd2hpbGUgKGlzVmFsaWRQb3NpdGlvbihuZXdSb3csIG5ld0NvbCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHBpZWNlID0gYm9hcmRbbmV3Um93XVtuZXdDb2xdLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBpZiAocGllY2UgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzT3Bwb25lbnRQaWVjZShib2FyZFtuZXdSb3ddW25ld0NvbF0sIGlzV2hpdGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwaWVjZSA9PT0gJ3EnIHx8IFxuICAgICAgICAgICAgICAgICAgICAgICAgKHBpZWNlID09PSAncicgJiYgKGRyID09PSAwIHx8IGRjID09PSAwKSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIChwaWVjZSA9PT0gJ2InICYmIGRyICE9PSAwICYmIGRjICE9PSAwKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKHBpZWNlID09PSAnaycgJiYgZGlzdGFuY2UgPT09IDEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ld1JvdyArPSBkcjtcbiAgICAgICAgICAgIG5ld0NvbCArPSBkYztcbiAgICAgICAgICAgIGRpc3RhbmNlKys7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldFN0cmFpZ2h0TW92ZXMoYm9hcmQ6IEJvYXJkLCByb3c6IG51bWJlciwgY29sOiBudW1iZXIsIGlzV2hpdGU6IGJvb2xlYW4pOiBbbnVtYmVyLCBudW1iZXJdW10ge1xuICAgIGNvbnN0IG1vdmVzOiBbbnVtYmVyLCBudW1iZXJdW10gPSBbXTtcbiAgICBjb25zdCBkaXJlY3Rpb25zID0gW1stMSwgMF0sIFsxLCAwXSwgWzAsIC0xXSwgWzAsIDFdXTtcblxuICAgIGZvciAoY29uc3QgW2RyLCBkY10gb2YgZGlyZWN0aW9ucykge1xuICAgICAgICBsZXQgbmV3Um93ID0gcm93ICsgZHI7XG4gICAgICAgIGxldCBuZXdDb2wgPSBjb2wgKyBkYztcbiAgICAgICAgd2hpbGUgKGlzVmFsaWRQb3NpdGlvbihuZXdSb3csIG5ld0NvbCkpIHtcbiAgICAgICAgICAgIGlmIChib2FyZFtuZXdSb3ddW25ld0NvbF0gPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgbW92ZXMucHVzaChbbmV3Um93LCBuZXdDb2xdKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNPcHBvbmVudFBpZWNlKGJvYXJkW25ld1Jvd11bbmV3Q29sXSwgaXNXaGl0ZSkpIHtcbiAgICAgICAgICAgICAgICBtb3Zlcy5wdXNoKFtuZXdSb3csIG5ld0NvbF0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ld1JvdyArPSBkcjtcbiAgICAgICAgICAgIG5ld0NvbCArPSBkYztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtb3Zlcztcbn1cblxuZnVuY3Rpb24gZ2V0RGlhZ29uYWxNb3Zlcyhib2FyZDogQm9hcmQsIHJvdzogbnVtYmVyLCBjb2w6IG51bWJlciwgaXNXaGl0ZTogYm9vbGVhbik6IFtudW1iZXIsIG51bWJlcl1bXSB7XG4gICAgY29uc3QgbW92ZXM6IFtudW1iZXIsIG51bWJlcl1bXSA9IFtdO1xuICAgIGNvbnN0IGRpcmVjdGlvbnMgPSBbWy0xLCAtMV0sIFstMSwgMV0sIFsxLCAtMV0sIFsxLCAxXV07XG5cbiAgICBmb3IgKGNvbnN0IFtkciwgZGNdIG9mIGRpcmVjdGlvbnMpIHtcbiAgICAgICAgbGV0IG5ld1JvdyA9IHJvdyArIGRyO1xuICAgICAgICBsZXQgbmV3Q29sID0gY29sICsgZGM7XG4gICAgICAgIHdoaWxlIChpc1ZhbGlkUG9zaXRpb24obmV3Um93LCBuZXdDb2wpKSB7XG4gICAgICAgICAgICBpZiAoYm9hcmRbbmV3Um93XVtuZXdDb2xdID09PSAnJykge1xuICAgICAgICAgICAgICAgIG1vdmVzLnB1c2goW25ld1JvdywgbmV3Q29sXSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzT3Bwb25lbnRQaWVjZShib2FyZFtuZXdSb3ddW25ld0NvbF0sIGlzV2hpdGUpKSB7XG4gICAgICAgICAgICAgICAgbW92ZXMucHVzaChbbmV3Um93LCBuZXdDb2xdKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdSb3cgKz0gZHI7XG4gICAgICAgICAgICBuZXdDb2wgKz0gZGM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbW92ZXM7XG59XG5cbmZ1bmN0aW9uIGlzVmFsaWRQb3NpdGlvbihyb3c6IG51bWJlciwgY29sOiBudW1iZXIpOiBib29sZWFuIHtcbiAgICByZXR1cm4gcm93ID49IDAgJiYgcm93IDwgOCAmJiBjb2wgPj0gMCAmJiBjb2wgPCA4O1xufVxuXG5mdW5jdGlvbiBpc09wcG9uZW50UGllY2UocGllY2U6IFBpZWNlLCBpc1doaXRlOiBib29sZWFuKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHBpZWNlICE9PSAnJyAmJiAoaXNXaGl0ZSA/IHBpZWNlID09PSBwaWVjZS50b0xvd2VyQ2FzZSgpIDogcGllY2UgPT09IHBpZWNlLnRvVXBwZXJDYXNlKCkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNDaGVjayhib2FyZDogQm9hcmQsIGlzV2hpdGVLaW5nOiBib29sZWFuKTogYm9vbGVhbiB7XG4gICAgY29uc3Qga2luZ1BpZWNlID0gaXNXaGl0ZUtpbmcgPyAnSycgOiAnayc7XG4gICAgZm9yIChsZXQgcm93ID0gMDsgcm93IDwgODsgcm93KyspIHtcbiAgICAgICAgZm9yIChsZXQgY29sID0gMDsgY29sIDwgODsgY29sKyspIHtcbiAgICAgICAgICAgIGlmIChib2FyZFtyb3ddW2NvbF0gPT09IGtpbmdQaWVjZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc1NxdWFyZVVuZGVyQXR0YWNrKGJvYXJkLCByb3csIGNvbCwgaXNXaGl0ZUtpbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTsgLy8gVGhpcyBzaG91bGQgbmV2ZXIgaGFwcGVuIGluIGEgdmFsaWQgY2hlc3MgcG9zaXRpb25cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzQ2hlY2ttYXRlKGJvYXJkOiBCb2FyZCwgaXNXaGl0ZUtpbmc6IGJvb2xlYW4pOiBib29sZWFuIHtcbiAgICBpZiAoIWlzQ2hlY2soYm9hcmQsIGlzV2hpdGVLaW5nKSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgZm9yIChsZXQgcm93ID0gMDsgcm93IDwgODsgcm93KyspIHtcbiAgICAgICAgZm9yIChsZXQgY29sID0gMDsgY29sIDwgODsgY29sKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHBpZWNlID0gYm9hcmRbcm93XVtjb2xdO1xuICAgICAgICAgICAgaWYgKHBpZWNlICE9PSAnJyAmJiAoaXNXaGl0ZUtpbmcgPyBwaWVjZSA9PT0gcGllY2UudG9VcHBlckNhc2UoKSA6IHBpZWNlID09PSBwaWVjZS50b0xvd2VyQ2FzZSgpKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1vdmVzID0gZ2V0VmFsaWRNb3Zlcyhib2FyZCwgcm93LCBjb2wsIHRydWUsIGZhbHNlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgaWYgKG1vdmVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBtb3ZlUHV0c093bktpbmdJbkNoZWNrKGJvYXJkOiBCb2FyZCwgZnJvbVJvdzogbnVtYmVyLCBmcm9tQ29sOiBudW1iZXIsIHRvUm93OiBudW1iZXIsIHRvQ29sOiBudW1iZXIsIGlzV2hpdGU6IGJvb2xlYW4pOiBib29sZWFuIHtcbiAgICBjb25zdCBuZXdCb2FyZCA9IGJvYXJkLm1hcChyb3cgPT4gWy4uLnJvd10pO1xuICAgIG5ld0JvYXJkW3RvUm93XVt0b0NvbF0gPSBuZXdCb2FyZFtmcm9tUm93XVtmcm9tQ29sXTtcbiAgICBuZXdCb2FyZFtmcm9tUm93XVtmcm9tQ29sXSA9ICcnO1xuICAgIHJldHVybiBpc0NoZWNrKG5ld0JvYXJkLCBpc1doaXRlKTtcbn1cblxuIl0sIm5hbWVzIjpbImdldFZhbGlkTW92ZXMiLCJib2FyZCIsInJvdyIsImNvbCIsImNvbnNpZGVyUGluIiwiY2FuQ2FzdGxlS2luZ3NpZGUiLCJjYW5DYXN0bGVRdWVlbnNpZGUiLCJwaWVjZSIsImlzV2hpdGUiLCJ0b1VwcGVyQ2FzZSIsIm1vdmVzIiwidG9Mb3dlckNhc2UiLCJnZXRQYXduTW92ZXMiLCJnZXRSb29rTW92ZXMiLCJnZXRLbmlnaHRNb3ZlcyIsImdldEJpc2hvcE1vdmVzIiwiZ2V0UXVlZW5Nb3ZlcyIsImdldEtpbmdNb3ZlcyIsImZpbHRlciIsIm5ld1JvdyIsIm5ld0NvbCIsIm1vdmVQdXRzT3duS2luZ0luQ2hlY2siLCJkaXJlY3Rpb24iLCJzdGFydFJvdyIsInB1c2giLCJkY29sIiwiaXNPcHBvbmVudFBpZWNlIiwiZ2V0U3RyYWlnaHRNb3ZlcyIsImtuaWdodE1vdmVzIiwiZHIiLCJkYyIsImlzVmFsaWRQb3NpdGlvbiIsImdldERpYWdvbmFsTW92ZXMiLCJraW5nTW92ZXMiLCJnZXRDYXN0bGluZ01vdmVzIiwiY2FzdGxpbmdNb3ZlcyIsImlzQ2hlY2siLCJiYWNrUmFuayIsImlzU3F1YXJlVW5kZXJBdHRhY2siLCJvcHBvbmVudENvbG9yIiwiZGlyZWN0aW9ucyIsInBhd25EaXJlY3Rpb24iLCJkaXN0YW5jZSIsImlzV2hpdGVLaW5nIiwia2luZ1BpZWNlIiwiaXNDaGVja21hdGUiLCJsZW5ndGgiLCJmcm9tUm93IiwiZnJvbUNvbCIsInRvUm93IiwidG9Db2wiLCJuZXdCb2FyZCIsIm1hcCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./chessLogic.ts\n"));

/***/ })

});